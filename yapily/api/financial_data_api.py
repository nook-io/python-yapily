# coding: utf-8

"""
Yapily API

The Yapily API enables connections between your application and users' banks. For more information check out our [documentation](https://docs.yapily.com/).<br><br>In particular, make sure to view our [Getting Started](https://docs.yapily.com/pages/home/getting-started/) steps if this is your first time here.<br><br>While testing the API, our list of [sandbox credentials](https://docs.yapily.com/pages/key-concepts/sandbox-credentials/) maybe useful.

The version of the OpenAPI document: 7.2.0
Contact: support@yapily.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

import re  # noqa: F401

from pydantic import validate_arguments
from typing import Optional

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist


from yapily.models.account_api_list_response import AccountApiListResponse
from yapily.models.api_list_response_of_account_statement import (
    ApiListResponseOfAccountStatement,
)
from yapily.models.api_list_response_of_beneficiary import ApiListResponseOfBeneficiary
from yapily.models.api_list_response_of_category import ApiListResponseOfCategory
from yapily.models.api_list_response_of_direct_debit_response import (
    ApiListResponseOfDirectDebitResponse,
)
from yapily.models.api_list_response_of_payment_response import (
    ApiListResponseOfPaymentResponse,
)
from yapily.models.api_list_response_of_real_time_transaction import (
    ApiListResponseOfRealTimeTransaction,
)
from yapily.models.api_list_response_of_transaction import ApiListResponseOfTransaction
from yapily.models.api_response_of_account import ApiResponseOfAccount
from yapily.models.api_response_of_account_statement import (
    ApiResponseOfAccountStatement,
)
from yapily.models.api_response_of_balances import ApiResponseOfBalances
from yapily.models.api_response_of_identity import ApiResponseOfIdentity
from yapily.models.sort_enum import SortEnum

from yapily.api_client import ApiClient
from yapily.api_response import ApiResponse
from yapily.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)


class FinancialDataApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    async def get_account(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponseOfAccount:  # noqa: E501
        """Get Account  # noqa: E501

        Returns the account and balance information for a user's specified account.<br><br>Feature: `ACCOUNT`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiResponseOfAccount
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_with_http_info(
            account_id,
            consent,
            psu_id,
            psu_corporate_id,
            psu_ip_address,
            sub_application,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_account_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account  # noqa: E501

        Returns the account and balance information for a user's specified account.<br><br>Feature: `ACCOUNT`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiResponseOfAccount, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "account_id",
            "consent",
            "psu_id",
            "psu_corporate_id",
            "psu_ip_address",
            "sub_application",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["psu_id"] is not None:
            _header_params["psu-id"] = _params["psu_id"]

        if _params["psu_corporate_id"] is not None:
            _header_params["psu-corporate-id"] = _params["psu_corporate_id"]

        if _params["psu_ip_address"] is not None:
            _header_params["psu-ip-address"] = _params["psu_ip_address"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiResponseOfAccount",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_account_balances(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponseOfBalances:  # noqa: E501
        """Get Account Balances  # noqa: E501

        Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiResponseOfBalances
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_balances_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_balances_with_http_info(
            account_id,
            consent,
            psu_id,
            psu_corporate_id,
            psu_ip_address,
            sub_application,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_account_balances_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Balances  # noqa: E501

        Returns the balance for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNT_BALANCES`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiResponseOfBalances, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "account_id",
            "consent",
            "psu_id",
            "psu_corporate_id",
            "psu_ip_address",
            "sub_application",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_balances" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["psu_id"] is not None:
            _header_params["psu-id"] = _params["psu_id"]

        if _params["psu_corporate_id"] is not None:
            _header_params["psu-corporate-id"] = _params["psu_corporate_id"]

        if _params["psu_ip_address"] is not None:
            _header_params["psu-ip-address"] = _params["psu_ip_address"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiResponseOfBalances",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/balances",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_account_direct_debits(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfDirectDebitResponse:  # noqa: E501
        """Get Account Direct Debits  # noqa: E501

        Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfDirectDebitResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_direct_debits_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_direct_debits_with_http_info(
            account_id, consent, sub_application, limit, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_account_direct_debits_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Direct Debits  # noqa: E501

        Returns the list of direct debits for an account.<br><br>Feature: `ACCOUNT_DIRECT_DEBITS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfDirectDebitResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["account_id", "consent", "sub_application", "limit", "raw"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_direct_debits" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfDirectDebitResponse",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/direct-debits",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_account_periodic_payments(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfPaymentResponse:  # noqa: E501
        """Get Account Periodic Payments  # noqa: E501

        Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfPaymentResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_periodic_payments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_periodic_payments_with_http_info(
            account_id, consent, sub_application, limit, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_account_periodic_payments_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Periodic Payments  # noqa: E501

        Returns the list of periodic payments (standing orders in the UK) for an account.<br><br>Feature: `ACCOUNT_PERIODIC_PAYMENTS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfPaymentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["account_id", "consent", "sub_application", "limit", "raw"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_periodic_payments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfPaymentResponse",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/periodic-payments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_account_scheduled_payments(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfPaymentResponse:  # noqa: E501
        """Get Account Scheduled Payments  # noqa: E501

        Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfPaymentResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_account_scheduled_payments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_account_scheduled_payments_with_http_info(
            account_id, consent, sub_application, limit, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_account_scheduled_payments_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Scheduled Payments  # noqa: E501

        Returns the list of scheduled payments for an account.<br><br>Feature: `ACCOUNT_SCHEDULED_PAYMENTS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfPaymentResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["account_id", "consent", "sub_application", "limit", "raw"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_scheduled_payments" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfPaymentResponse",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/scheduled-payments",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_accounts(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> AccountApiListResponse:  # noqa: E501
        """Get Accounts  # noqa: E501

        Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountApiListResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_accounts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_accounts_with_http_info(
            consent,
            psu_id,
            psu_corporate_id,
            psu_ip_address,
            sub_application,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_accounts_with_http_info(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Accounts  # noqa: E501

        Returns all accounts and balances for the end user associated with the presented consent token.<br><br>Feature: `ACCOUNTS`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountApiListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "consent",
            "psu_id",
            "psu_corporate_id",
            "psu_ip_address",
            "sub_application",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_accounts" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["psu_id"] is not None:
            _header_params["psu-id"] = _params["psu_id"]

        if _params["psu_corporate_id"] is not None:
            _header_params["psu-corporate-id"] = _params["psu_corporate_id"]

        if _params["psu_ip_address"] is not None:
            _header_params["psu-ip-address"] = _params["psu_ip_address"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "AccountApiListResponse",
        }

        return await self.api_client.call_api(
            "/accounts",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_beneficiaries(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfBeneficiary:  # noqa: E501
        """Get Account Beneficiaries  # noqa: E501

        Returns all the beneficiaries of a user's account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfBeneficiary
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_beneficiaries_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_beneficiaries_with_http_info(
            account_id, consent, sub_application, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_beneficiaries_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Beneficiaries  # noqa: E501

        Returns all the beneficiaries of a user's account.<br><br>Feature: `ACCOUNT_BENEFICIARIES`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfBeneficiary, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["account_id", "consent", "sub_application", "raw"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_beneficiaries" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfBeneficiary",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/beneficiaries",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_categories(
        self,
        country: Annotated[
            StrictStr,
            Field(
                ..., description="__Mandatory__. The 2 letter country code e.g. 'GB'."
            ),
        ],
        **kwargs,
    ) -> ApiListResponseOfCategory:  # noqa: E501
        """Get Categories  # noqa: E501

        Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.  # noqa: E501

        :param country: __Mandatory__. The 2 letter country code e.g. 'GB'. (required)
        :type country: str
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfCategory
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_categories_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_categories_with_http_info(country, **kwargs)  # noqa: E501

    @validate_arguments
    async def get_categories_with_http_info(
        self,
        country: Annotated[
            StrictStr,
            Field(
                ..., description="__Mandatory__. The 2 letter country code e.g. 'GB'."
            ),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Categories  # noqa: E501

        Used to retrieve the list of categories returned by the Yapily Categorisation engine for a given locale. <br><br>See [Data Enrichment](https://docs.yapily.com/pages/key-concepts/account-data/data-enrichment/intro-to-data-enrichment/) for more information.  # noqa: E501

        :param country: __Mandatory__. The 2 letter country code e.g. 'GB'. (required)
        :type country: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfCategory, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["country"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_categories" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["country"] is not None:
            _path_params["country"] = _params["country"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfCategory",
        }

        return await self.api_client.call_api(
            "/categories/{country}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_identity(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponseOfIdentity:  # noqa: E501
        """Get Identity  # noqa: E501

        Returns the identity information for an account.<br><br>Feature: `IDENTITY`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiResponseOfIdentity
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_identity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_identity_with_http_info(
            consent, sub_application, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_identity_with_http_info(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Identity  # noqa: E501

        Returns the identity information for an account.<br><br>Feature: `IDENTITY`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiResponseOfIdentity, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["consent", "sub_application", "raw"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_identity" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiResponseOfIdentity",
        }

        return await self.api_client.call_api(
            "/identity",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_real_time_transactions(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        cursor: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfRealTimeTransaction:  # noqa: E501
        """Get Real Time Account Transactions  # noqa: E501

        Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param cursor: __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
        :type cursor: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfRealTimeTransaction
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_real_time_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_real_time_transactions_with_http_info(
            account_id,
            consent,
            psu_id,
            psu_corporate_id,
            psu_ip_address,
            sub_application,
            var_from,
            before,
            cursor,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_real_time_transactions_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        cursor: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Real Time Account Transactions  # noqa: E501

        Used to get the account transactions for an account in real time with cursor pagination<br><br>Feature: `ACCOUNT_TRANSACTIONS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/knowledge/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param cursor: __Optional__. The cursor token supplied by a previous call. The cursor represents a location in the data set.
        :type cursor: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfRealTimeTransaction, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "account_id",
            "consent",
            "psu_id",
            "psu_corporate_id",
            "psu_ip_address",
            "sub_application",
            "var_from",
            "before",
            "cursor",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_real_time_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("var_from") is not None:  # noqa: E501
            _query_params.append(("from", _params["var_from"]))

        if _params.get("before") is not None:  # noqa: E501
            _query_params.append(("before", _params["before"]))

        if _params.get("cursor") is not None:  # noqa: E501
            _query_params.append(("cursor", _params["cursor"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["psu_id"] is not None:
            _header_params["psu-id"] = _params["psu_id"]

        if _params["psu_corporate_id"] is not None:
            _header_params["psu-corporate-id"] = _params["psu_corporate_id"]

        if _params["psu_ip_address"] is not None:
            _header_params["psu-ip-address"] = _params["psu_ip_address"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfRealTimeTransaction",
            "401": "ApiResponseError",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/real-time/transactions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_statement(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        statement_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The statement Id of the statement file.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponseOfAccountStatement:  # noqa: E501
        """Get Account Statement  # noqa: E501

        Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param statement_id: __Mandatory__. The statement Id of the statement file. (required)
        :type statement_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiResponseOfAccountStatement
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_statement_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_statement_with_http_info(
            consent, account_id, statement_id, sub_application, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_statement_with_http_info(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        statement_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The statement Id of the statement file.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Statement  # noqa: E501

        Returns a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param statement_id: __Mandatory__. The statement Id of the statement file. (required)
        :type statement_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiResponseOfAccountStatement, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "consent",
            "account_id",
            "statement_id",
            "sub_application",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statement" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        if _params["statement_id"] is not None:
            _path_params["statementId"] = _params["statement_id"]

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiResponseOfAccountStatement",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/statements/{statementId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_statement_file(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        statement_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The statement Id of the statement file.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> bytearray:  # noqa: E501
        """Get Account Statement File  # noqa: E501

        Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param statement_id: __Mandatory__. The statement Id of the statement file. (required)
        :type statement_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_statement_file_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_statement_file_with_http_info(
            consent, account_id, statement_id, sub_application, raw, **kwargs
        )  # noqa: E501

    @validate_arguments
    async def get_statement_file_with_http_info(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        statement_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The statement Id of the statement file.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Statement File  # noqa: E501

        Returns a PDF file of a statement for an account.<br><br>Feature: `ACCOUNT_STATEMENT_FILE`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param statement_id: __Mandatory__. The statement Id of the statement file. (required)
        :type statement_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "consent",
            "account_id",
            "statement_id",
            "sub_application",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statement_file" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        if _params["statement_id"] is not None:
            _path_params["statementId"] = _params["statement_id"]

        # process the query parameters
        _query_params = []
        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/pdf", "application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "bytearray",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/statements/{statementId}/file",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_statements(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ). "
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        sort: Annotated[
            Optional[SortEnum],
            Field(
                description="__Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The number of transaction records to be skipped. Used primarily with paginated results."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfAccountStatement:  # noqa: E501
        """Get Account Statements  # noqa: E501

        Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param sort: __Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending
        :type sort: SortEnum
        :param offset: __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
        :type offset: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfAccountStatement
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_statements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_statements_with_http_info(
            consent,
            account_id,
            sub_application,
            var_from,
            before,
            limit,
            sort,
            offset,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_statements_with_http_info(
        self,
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ). "
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        sort: Annotated[
            Optional[SortEnum],
            Field(
                description="__Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The number of transaction records to be skipped. Used primarily with paginated results."
            ),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Statements  # noqa: E501

        Returns the list of statements for an account.<br><br>Feature: `ACCOUNT_STATEMENTS`  # noqa: E501

        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param sort: __Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending
        :type sort: SortEnum
        :param offset: __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
        :type offset: int
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfAccountStatement, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "consent",
            "account_id",
            "sub_application",
            "var_from",
            "before",
            "limit",
            "sort",
            "offset",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statements" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("var_from") is not None:  # noqa: E501
            _query_params.append(("from", _params["var_from"]))

        if _params.get("before") is not None:  # noqa: E501
            _query_params.append(("before", _params["before"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"].value))

        if _params.get("offset") is not None:  # noqa: E501
            _query_params.append(("offset", _params["offset"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfAccountStatement",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/statements",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_transactions(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_with: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="__Optional__. Acceptable value: `categorisation`. When set, will include enrichment data in the transactions returned. <br><br>Enrichment data is optional, e.g. when 'categorisation' enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently. __This is a legacy feature and will be deprecated. Date TBC__"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ). "
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        sort: Annotated[
            Optional[SortEnum],
            Field(
                description="__Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The number of transaction records to be skipped. Used primarily with paginated results."
            ),
        ] = None,
        cursor: Annotated[
            Optional[StrictStr],
            Field(description="__Optional__. This property is not currently in use."),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiListResponseOfTransaction:  # noqa: E501
        """Get Account Transactions  # noqa: E501

        Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_with: __Optional__. Acceptable value: `categorisation`. When set, will include enrichment data in the transactions returned. <br><br>Enrichment data is optional, e.g. when 'categorisation' enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently. __This is a legacy feature and will be deprecated. Date TBC__
        :type var_with: List[str]
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param sort: __Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending
        :type sort: SortEnum
        :param offset: __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
        :type offset: int
        :param cursor: __Optional__. This property is not currently in use.
        :type cursor: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiListResponseOfTransaction
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return await self.get_transactions_with_http_info(
            account_id,
            consent,
            psu_id,
            psu_corporate_id,
            psu_ip_address,
            sub_application,
            var_with,
            var_from,
            before,
            limit,
            sort,
            offset,
            cursor,
            raw,
            **kwargs,
        )  # noqa: E501

    @validate_arguments
    async def get_transactions_with_http_info(
        self,
        account_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The account Id of the user's bank account.",
            ),
        ],
        consent: Annotated[
            StrictStr,
            Field(
                ...,
                description="__Mandatory__. The `consent-token` containing the user's authorisation to make the request.",
            ),
        ],
        psu_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_corporate_id: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        psu_ip_address: Annotated[
            Optional[StrictStr],
            Field(
                description="__Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required."
            ),
        ] = None,
        sub_application: Annotated[
            Optional[StrictStr],
            Field(
                description="The sub-application ID to which event type is being subscribed to"
            ),
        ] = None,
        var_with: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="__Optional__. Acceptable value: `categorisation`. When set, will include enrichment data in the transactions returned. <br><br>Enrichment data is optional, e.g. when 'categorisation' enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently. __This is a legacy feature and will be deprecated. Date TBC__"
            ),
        ] = None,
        var_from: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ). "
            ),
        ] = None,
        before: Annotated[
            Optional[StrictStr],
            Field(
                description="__Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ)."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000."
            ),
        ] = None,
        sort: Annotated[
            Optional[SortEnum],
            Field(
                description="__Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending"
            ),
        ] = None,
        offset: Annotated[
            Optional[StrictInt],
            Field(
                description="__Optional__. The number of transaction records to be skipped. Used primarily with paginated results."
            ),
        ] = None,
        cursor: Annotated[
            Optional[StrictStr],
            Field(description="__Optional__. This property is not currently in use."),
        ] = None,
        raw: Annotated[
            Optional[StrictBool],
            Field(
                description="__Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """Get Account Transactions  # noqa: E501

        Returns the account transactions for an account.<br><br>Feature: `ACCOUNT_TRANSACTIONS`  # noqa: E501

        :param account_id: __Mandatory__. The account Id of the user's bank account. (required)
        :type account_id: str
        :param consent: __Mandatory__. The `consent-token` containing the user's authorisation to make the request. (required)
        :type consent: str
        :param psu_id: __Conditional__. Represents the user's login ID for the `Institution` to a personal account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_id: str
        :param psu_corporate_id: __Conditional__. Represents the user's login ID for the `Institution` to a business account. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_corporate_id: str
        :param psu_ip_address: __Conditional__. The IP address of the PSU. <br><br>See [PSU identifiers](https://docs.yapily.com/pages/knowledge/open-banking/psu_identifiers/) to see if this header is required.
        :type psu_ip_address: str
        :param sub_application: The sub-application ID to which event type is being subscribed to
        :type sub_application: str
        :param var_with: __Optional__. Acceptable value: `categorisation`. When set, will include enrichment data in the transactions returned. <br><br>Enrichment data is optional, e.g. when 'categorisation' enrichment data is requested, the enrichment response will include categorisation data and merchant name, only if it can be evaluated from the transaction. This service is limited for UK institution transactions currently. __This is a legacy feature and will be deprecated. Date TBC__
        :type var_with: List[str]
        :param var_from: __Optional__. Returned transactions will be on or after this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type var_from: str
        :param before: __Optional__. Returned transactions will be on or before this date (yyyy-MM-dd'T'HH:mm:ss.SSSZ).
        :type before: str
        :param limit: __Optional__. The maximum number of transaction records to be returned. Must be between 1 and 1000.
        :type limit: int
        :param sort: __Optional__. Sort transaction records by date ascending with 'date' or descending with '-date'. The default sort order is descending
        :type sort: SortEnum
        :param offset: __Optional__. The number of transaction records to be skipped. Used primarily with paginated results.
        :type offset: int
        :param cursor: __Optional__. This property is not currently in use.
        :type cursor: str
        :param raw: __Optional__. Used to obtain the raw request and response to and from the <code>Institution</code>.
        :type raw: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiListResponseOfTransaction, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "account_id",
            "consent",
            "psu_id",
            "psu_corporate_id",
            "psu_ip_address",
            "sub_application",
            "var_with",
            "var_from",
            "before",
            "limit",
            "sort",
            "offset",
            "cursor",
            "raw",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_transactions" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["account_id"] is not None:
            _path_params["accountId"] = _params["account_id"]

        # process the query parameters
        _query_params = []
        if _params.get("var_with") is not None:  # noqa: E501
            _query_params.append(("with", _params["var_with"]))
            _collection_formats["with"] = "multi"

        if _params.get("var_from") is not None:  # noqa: E501
            _query_params.append(("from", _params["var_from"]))

        if _params.get("before") is not None:  # noqa: E501
            _query_params.append(("before", _params["before"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"].value))

        if _params.get("offset") is not None:  # noqa: E501
            _query_params.append(("offset", _params["offset"]))

        if _params.get("cursor") is not None:  # noqa: E501
            _query_params.append(("cursor", _params["cursor"]))

        if _params.get("raw") is not None:  # noqa: E501
            _query_params.append(("raw", _params["raw"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["consent"] is not None:
            _header_params["consent"] = _params["consent"]

        if _params["psu_id"] is not None:
            _header_params["psu-id"] = _params["psu_id"]

        if _params["psu_corporate_id"] is not None:
            _header_params["psu-corporate-id"] = _params["psu_corporate_id"]

        if _params["psu_ip_address"] is not None:
            _header_params["psu-ip-address"] = _params["psu_ip_address"]

        if _params["sub_application"] is not None:
            _header_params["sub-application"] = _params["sub_application"]

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json;charset=UTF-8"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["basicAuth"]  # noqa: E501

        _response_types_map = {
            "200": "ApiListResponseOfTransaction",
        }

        return await self.api_client.call_api(
            "/accounts/{accountId}/transactions",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
