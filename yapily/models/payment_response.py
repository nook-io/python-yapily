# coding: utf-8

"""
Yapily API

The Yapily API enables connections between your application and users' banks. For more information check out our [documentation](https://docs.yapily.com/).<br><br>In particular, make sure to view our [Getting Started](https://docs.yapily.com/pages/home/getting-started/) steps if this is your first time here.<br><br>While testing the API, our list of [sandbox credentials](https://docs.yapily.com/pages/key-concepts/sandbox-credentials/) maybe useful.

The version of the OpenAPI document: 7.2.0
Contact: support@yapily.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Optional, Union
from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
from yapily.models.amount import Amount
from yapily.models.exchange_rate_information_response import (
    ExchangeRateInformationResponse,
)
from yapily.models.frequency_response import FrequencyResponse
from yapily.models.payee import Payee
from yapily.models.payer import Payer
from yapily.models.payment_charge_details import PaymentChargeDetails
from yapily.models.payment_status import PaymentStatus
from yapily.models.payment_status_details import PaymentStatusDetails
from yapily.models.priority_code_enum import PriorityCodeEnum
from yapily.models.refund_account import RefundAccount


class PaymentResponse(BaseModel):
    """
    PaymentResponse
    """

    id: Optional[StrictStr] = Field(
        default=None, description="Unique identifier of the payment."
    )
    institution_consent_id: Optional[StrictStr] = Field(
        default=None,
        alias="institutionConsentId",
        description="Identification of the consent at the Institution.",
    )
    payment_idempotency_id: Optional[StrictStr] = Field(
        default=None,
        alias="paymentIdempotencyId",
        description="__Mandatory__. A unique identifier that you must provide to identify the payment. This can be any alpha-numeric string but is limited to a maximum of 35 characters.",
    )
    payment_lifecycle_id: Optional[StrictStr] = Field(
        default=None, alias="paymentLifecycleId"
    )
    status: Optional[PaymentStatus] = None
    status_details: Optional[PaymentStatusDetails] = Field(
        default=None, alias="statusDetails"
    )
    payer: Optional[Payer] = None
    payee_details: Optional[Payee] = Field(default=None, alias="payeeDetails")
    reference: Optional[StrictStr] = Field(
        default=None,
        description="__Optional__. The payment reference or description. Limited to a maximum of 18 characters long.",
    )
    amount: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, description="Monetary amount."
    )
    currency: Optional[StrictStr] = Field(
        default=None,
        description="Currency the payment amount is denoted in. Specified as a 3-letter ISO 4217 code.",
    )
    amount_details: Optional[Amount] = Field(default=None, alias="amountDetails")
    created_at: Optional[datetime] = Field(
        default=None,
        alias="createdAt",
        description="Date and time of when the payment request was created.",
    )
    first_payment_amount: Optional[Amount] = Field(
        default=None, alias="firstPaymentAmount"
    )
    first_payment_date_time: Optional[datetime] = Field(
        default=None,
        alias="firstPaymentDateTime",
        description="Date and time of when the first payment request is to be made.",
    )
    next_payment_amount: Optional[Amount] = Field(
        default=None, alias="nextPaymentAmount"
    )
    next_payment_date_time: Optional[datetime] = Field(
        default=None,
        alias="nextPaymentDateTime",
        description="__Conditional__. Defines when the recurring payment is to be made.",
    )
    final_payment_amount: Optional[Amount] = Field(
        default=None, alias="finalPaymentAmount"
    )
    final_payment_date_time: Optional[datetime] = Field(
        default=None,
        alias="finalPaymentDateTime",
        description="Date and time of when the final payment is to be made.",
    )
    number_of_payments: Optional[StrictInt] = Field(
        default=None,
        alias="numberOfPayments",
        description="Number of recurring payment requests to be made as part of the instructed payment schedule.",
    )
    previous_payment_amount: Optional[Amount] = Field(
        default=None, alias="previousPaymentAmount"
    )
    previous_payment_date_time: Optional[datetime] = Field(
        default=None,
        alias="previousPaymentDateTime",
        description="Date and time of when the previous payment request was posted.",
    )
    charge_details: Optional[conlist(PaymentChargeDetails)] = Field(
        default=None, alias="chargeDetails"
    )
    scheduled_payment_type: Optional[StrictStr] = Field(
        default=None,
        alias="scheduledPaymentType",
        description="Details the execution type and the payment date between the payer and the payee.",
    )
    scheduled_payment_date_time: Optional[datetime] = Field(
        default=None,
        alias="scheduledPaymentDateTime",
        description="Date and time of when the scheduled payment request will be made.",
    )
    frequency: Optional[FrequencyResponse] = None
    currency_of_transfer: Optional[StrictStr] = Field(
        default=None,
        alias="currencyOfTransfer",
        description="__Mandatory__. The currency to be transferred to the payee. This may differ from the currency the payment is denoted in and the currency of the payer's account. Specified as a 3-letter code (ISO 4217).",
    )
    purpose: Optional[StrictStr] = Field(
        default=None,
        description="Specifies the external purpose code for the `Institution` - IS0 20022.",
    )
    priority: Optional[PriorityCodeEnum] = None
    exchange_rate: Optional[ExchangeRateInformationResponse] = Field(
        default=None, alias="exchangeRate"
    )
    refund_account: Optional[RefundAccount] = Field(default=None, alias="refundAccount")
    bulk_amount_sum: Optional[Union[StrictFloat, StrictInt]] = Field(
        default=None, alias="bulkAmountSum"
    )
    __properties = [
        "id",
        "institutionConsentId",
        "paymentIdempotencyId",
        "paymentLifecycleId",
        "status",
        "statusDetails",
        "payer",
        "payeeDetails",
        "reference",
        "amount",
        "currency",
        "amountDetails",
        "createdAt",
        "firstPaymentAmount",
        "firstPaymentDateTime",
        "nextPaymentAmount",
        "nextPaymentDateTime",
        "finalPaymentAmount",
        "finalPaymentDateTime",
        "numberOfPayments",
        "previousPaymentAmount",
        "previousPaymentDateTime",
        "chargeDetails",
        "scheduledPaymentType",
        "scheduledPaymentDateTime",
        "frequency",
        "currencyOfTransfer",
        "purpose",
        "priority",
        "exchangeRate",
        "refundAccount",
        "bulkAmountSum",
    ]

    class Config:
        """Pydantic configuration"""

        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PaymentResponse:
        """Create an instance of PaymentResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of status_details
        if self.status_details:
            _dict["statusDetails"] = self.status_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payer
        if self.payer:
            _dict["payer"] = self.payer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payee_details
        if self.payee_details:
            _dict["payeeDetails"] = self.payee_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of amount_details
        if self.amount_details:
            _dict["amountDetails"] = self.amount_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of first_payment_amount
        if self.first_payment_amount:
            _dict["firstPaymentAmount"] = self.first_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of next_payment_amount
        if self.next_payment_amount:
            _dict["nextPaymentAmount"] = self.next_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of final_payment_amount
        if self.final_payment_amount:
            _dict["finalPaymentAmount"] = self.final_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of previous_payment_amount
        if self.previous_payment_amount:
            _dict["previousPaymentAmount"] = self.previous_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in charge_details (list)
        _items = []
        if self.charge_details:
            for _item in self.charge_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict["chargeDetails"] = _items
        # override the default output from pydantic by calling `to_dict()` of frequency
        if self.frequency:
            _dict["frequency"] = self.frequency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of exchange_rate
        if self.exchange_rate:
            _dict["exchangeRate"] = self.exchange_rate.to_dict()
        # override the default output from pydantic by calling `to_dict()` of refund_account
        if self.refund_account:
            _dict["refundAccount"] = self.refund_account.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PaymentResponse:
        """Create an instance of PaymentResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PaymentResponse.parse_obj(obj)

        _obj = PaymentResponse.parse_obj(
            {
                "id": obj.get("id"),
                "institution_consent_id": obj.get("institutionConsentId"),
                "payment_idempotency_id": obj.get("paymentIdempotencyId"),
                "payment_lifecycle_id": obj.get("paymentLifecycleId"),
                "status": obj.get("status"),
                "status_details": PaymentStatusDetails.from_dict(
                    obj.get("statusDetails")
                )
                if obj.get("statusDetails") is not None
                else None,
                "payer": Payer.from_dict(obj.get("payer"))
                if obj.get("payer") is not None
                else None,
                "payee_details": Payee.from_dict(obj.get("payeeDetails"))
                if obj.get("payeeDetails") is not None
                else None,
                "reference": obj.get("reference"),
                "amount": obj.get("amount"),
                "currency": obj.get("currency"),
                "amount_details": Amount.from_dict(obj.get("amountDetails"))
                if obj.get("amountDetails") is not None
                else None,
                "created_at": obj.get("createdAt"),
                "first_payment_amount": Amount.from_dict(obj.get("firstPaymentAmount"))
                if obj.get("firstPaymentAmount") is not None
                else None,
                "first_payment_date_time": obj.get("firstPaymentDateTime"),
                "next_payment_amount": Amount.from_dict(obj.get("nextPaymentAmount"))
                if obj.get("nextPaymentAmount") is not None
                else None,
                "next_payment_date_time": obj.get("nextPaymentDateTime"),
                "final_payment_amount": Amount.from_dict(obj.get("finalPaymentAmount"))
                if obj.get("finalPaymentAmount") is not None
                else None,
                "final_payment_date_time": obj.get("finalPaymentDateTime"),
                "number_of_payments": obj.get("numberOfPayments"),
                "previous_payment_amount": Amount.from_dict(
                    obj.get("previousPaymentAmount")
                )
                if obj.get("previousPaymentAmount") is not None
                else None,
                "previous_payment_date_time": obj.get("previousPaymentDateTime"),
                "charge_details": [
                    PaymentChargeDetails.from_dict(_item)
                    for _item in obj.get("chargeDetails")
                ]
                if obj.get("chargeDetails") is not None
                else None,
                "scheduled_payment_type": obj.get("scheduledPaymentType"),
                "scheduled_payment_date_time": obj.get("scheduledPaymentDateTime"),
                "frequency": FrequencyResponse.from_dict(obj.get("frequency"))
                if obj.get("frequency") is not None
                else None,
                "currency_of_transfer": obj.get("currencyOfTransfer"),
                "purpose": obj.get("purpose"),
                "priority": obj.get("priority"),
                "exchange_rate": ExchangeRateInformationResponse.from_dict(
                    obj.get("exchangeRate")
                )
                if obj.get("exchangeRate") is not None
                else None,
                "refund_account": RefundAccount.from_dict(obj.get("refundAccount"))
                if obj.get("refundAccount") is not None
                else None,
                "bulk_amount_sum": obj.get("bulkAmountSum"),
            }
        )
        return _obj
