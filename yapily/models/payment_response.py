# coding: utf-8

"""
    Yapily API

    The Yapily API enables connections between your application and users' banks. For more information check out our [documentation](https://docs.yapily.com/).<br><br>In particular, make sure to view our [Getting Started](https://docs.yapily.com/pages/home/getting-started/) steps if this is your first time here.<br><br>While testing the API, our list of [sandbox credentials](https://docs.yapily.com/pages/key-concepts/sandbox-credentials/) maybe useful.

    The version of the OpenAPI document: 2.13.1
    Contact: support@yapily.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import List, Optional, Union
from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
from yapily.models.amount import Amount
from yapily.models.exchange_rate_information_response import ExchangeRateInformationResponse
from yapily.models.frequency_response import FrequencyResponse
from yapily.models.payee import Payee
from yapily.models.payer import Payer
from yapily.models.payment_charge_details import PaymentChargeDetails
from yapily.models.payment_status import PaymentStatus
from yapily.models.payment_status_details import PaymentStatusDetails
from yapily.models.priority_code_enum import PriorityCodeEnum
from yapily.models.refund_account import RefundAccount

class PaymentResponse(BaseModel):
    """
    PaymentResponse
    """
    id: Optional[StrictStr] = None
    institution_consent_id: Optional[StrictStr] = Field(None, alias="institutionConsentId")
    payment_idempotency_id: Optional[StrictStr] = Field(None, alias="paymentIdempotencyId")
    payment_lifecycle_id: Optional[StrictStr] = Field(None, alias="paymentLifecycleId")
    status: Optional[PaymentStatus] = None
    status_details: Optional[PaymentStatusDetails] = Field(None, alias="statusDetails")
    payer: Optional[Payer] = None
    payee_details: Optional[Payee] = Field(None, alias="payeeDetails")
    reference: Optional[StrictStr] = None
    amount: Optional[Union[StrictFloat, StrictInt]] = None
    currency: Optional[StrictStr] = None
    amount_details: Optional[Amount] = Field(None, alias="amountDetails")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    first_payment_amount: Optional[Amount] = Field(None, alias="firstPaymentAmount")
    first_payment_date_time: Optional[datetime] = Field(None, alias="firstPaymentDateTime")
    next_payment_amount: Optional[Amount] = Field(None, alias="nextPaymentAmount")
    next_payment_date_time: Optional[datetime] = Field(None, alias="nextPaymentDateTime")
    final_payment_amount: Optional[Amount] = Field(None, alias="finalPaymentAmount")
    final_payment_date_time: Optional[datetime] = Field(None, alias="finalPaymentDateTime")
    number_of_payments: Optional[StrictInt] = Field(None, alias="numberOfPayments")
    previous_payment_amount: Optional[Amount] = Field(None, alias="previousPaymentAmount")
    previous_payment_date_time: Optional[datetime] = Field(None, alias="previousPaymentDateTime")
    charge_details: Optional[conlist(PaymentChargeDetails)] = Field(None, alias="chargeDetails")
    scheduled_payment_type: Optional[StrictStr] = Field(None, alias="scheduledPaymentType")
    scheduled_payment_date_time: Optional[datetime] = Field(None, alias="scheduledPaymentDateTime")
    frequency: Optional[FrequencyResponse] = None
    currency_of_transfer: Optional[StrictStr] = Field(None, alias="currencyOfTransfer")
    purpose: Optional[StrictStr] = None
    priority: Optional[PriorityCodeEnum] = None
    exchange_rate: Optional[ExchangeRateInformationResponse] = Field(None, alias="exchangeRate")
    refund_account: Optional[RefundAccount] = Field(None, alias="refundAccount")
    bulk_amount_sum: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="bulkAmountSum")
    __properties = ["id", "institutionConsentId", "paymentIdempotencyId", "paymentLifecycleId", "status", "statusDetails", "payer", "payeeDetails", "reference", "amount", "currency", "amountDetails", "createdAt", "firstPaymentAmount", "firstPaymentDateTime", "nextPaymentAmount", "nextPaymentDateTime", "finalPaymentAmount", "finalPaymentDateTime", "numberOfPayments", "previousPaymentAmount", "previousPaymentDateTime", "chargeDetails", "scheduledPaymentType", "scheduledPaymentDateTime", "frequency", "currencyOfTransfer", "purpose", "priority", "exchangeRate", "refundAccount", "bulkAmountSum"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PaymentResponse:
        """Create an instance of PaymentResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of status_details
        if self.status_details:
            _dict['statusDetails'] = self.status_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payer
        if self.payer:
            _dict['payer'] = self.payer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payee_details
        if self.payee_details:
            _dict['payeeDetails'] = self.payee_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of amount_details
        if self.amount_details:
            _dict['amountDetails'] = self.amount_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of first_payment_amount
        if self.first_payment_amount:
            _dict['firstPaymentAmount'] = self.first_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of next_payment_amount
        if self.next_payment_amount:
            _dict['nextPaymentAmount'] = self.next_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of final_payment_amount
        if self.final_payment_amount:
            _dict['finalPaymentAmount'] = self.final_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of previous_payment_amount
        if self.previous_payment_amount:
            _dict['previousPaymentAmount'] = self.previous_payment_amount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in charge_details (list)
        _items = []
        if self.charge_details:
            for _item in self.charge_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict['chargeDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of frequency
        if self.frequency:
            _dict['frequency'] = self.frequency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of exchange_rate
        if self.exchange_rate:
            _dict['exchangeRate'] = self.exchange_rate.to_dict()
        # override the default output from pydantic by calling `to_dict()` of refund_account
        if self.refund_account:
            _dict['refundAccount'] = self.refund_account.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PaymentResponse:
        """Create an instance of PaymentResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PaymentResponse.parse_obj(obj)

        _obj = PaymentResponse.parse_obj({
            "id": obj.get("id"),
            "institution_consent_id": obj.get("institutionConsentId"),
            "payment_idempotency_id": obj.get("paymentIdempotencyId"),
            "payment_lifecycle_id": obj.get("paymentLifecycleId"),
            "status": obj.get("status"),
            "status_details": PaymentStatusDetails.from_dict(obj.get("statusDetails")) if obj.get("statusDetails") is not None else None,
            "payer": Payer.from_dict(obj.get("payer")) if obj.get("payer") is not None else None,
            "payee_details": Payee.from_dict(obj.get("payeeDetails")) if obj.get("payeeDetails") is not None else None,
            "reference": obj.get("reference"),
            "amount": obj.get("amount"),
            "currency": obj.get("currency"),
            "amount_details": Amount.from_dict(obj.get("amountDetails")) if obj.get("amountDetails") is not None else None,
            "created_at": obj.get("createdAt"),
            "first_payment_amount": Amount.from_dict(obj.get("firstPaymentAmount")) if obj.get("firstPaymentAmount") is not None else None,
            "first_payment_date_time": obj.get("firstPaymentDateTime"),
            "next_payment_amount": Amount.from_dict(obj.get("nextPaymentAmount")) if obj.get("nextPaymentAmount") is not None else None,
            "next_payment_date_time": obj.get("nextPaymentDateTime"),
            "final_payment_amount": Amount.from_dict(obj.get("finalPaymentAmount")) if obj.get("finalPaymentAmount") is not None else None,
            "final_payment_date_time": obj.get("finalPaymentDateTime"),
            "number_of_payments": obj.get("numberOfPayments"),
            "previous_payment_amount": Amount.from_dict(obj.get("previousPaymentAmount")) if obj.get("previousPaymentAmount") is not None else None,
            "previous_payment_date_time": obj.get("previousPaymentDateTime"),
            "charge_details": [PaymentChargeDetails.from_dict(_item) for _item in obj.get("chargeDetails")] if obj.get("chargeDetails") is not None else None,
            "scheduled_payment_type": obj.get("scheduledPaymentType"),
            "scheduled_payment_date_time": obj.get("scheduledPaymentDateTime"),
            "frequency": FrequencyResponse.from_dict(obj.get("frequency")) if obj.get("frequency") is not None else None,
            "currency_of_transfer": obj.get("currencyOfTransfer"),
            "purpose": obj.get("purpose"),
            "priority": obj.get("priority"),
            "exchange_rate": ExchangeRateInformationResponse.from_dict(obj.get("exchangeRate")) if obj.get("exchangeRate") is not None else None,
            "refund_account": RefundAccount.from_dict(obj.get("refundAccount")) if obj.get("refundAccount") is not None else None,
            "bulk_amount_sum": obj.get("bulkAmountSum")
        })
        return _obj


